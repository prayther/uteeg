#! /bin/bash
#
# Description:
#
# This plugin will scan a log file (specified by the <log_file> option)
# for a specific pattern (specified by the <pattern> option).  Successive
# calls to the plugin script will only report *new* pattern matches in the
# log file, since an copy of the log file from the previous run is saved
# to <old_log_file>.
#
# Output:
#
# On the first run of the plugin, it will return an OK state with a message
# of "Log check data initialized".  On successive runs, it will return an OK
# state if *no* pattern matches have been found in the *difference* between the
# log file and the older copy of the log file.  If the plugin detects any 
# pattern matches in the log diff, it will return a CRITICAL state and print
# out a message is the following format: "(x) last_match", where "x" is the
# total number of pattern matches found in the file and "last_match" is the
# last entry in the log file which matches the pattern.
#
# Notes:
#
# If you use this plugin make sure to keep the following in mind:
#
#    1.  The "max_attempts" value for the service should be 1, as this
#        will prevent Nagios from retrying the service check (the
#        next time the check is run it will not produce the same results).
#
#    2.  The "notify_recovery" value for the service should be 0, so that
#        Nagios does not notify you of "recoveries" for the check.  Since
#        pattern matches in the log file will only be reported once and not
#        the next time, there will always be "recoveries" for the service, even
#        though recoveries really don't apply to this type of check.
#
#    3.  You *must* supply a different <old_file_log> for each service that
#        you define to use this plugin script - even if the different services
#        check the same <log_file> for pattern matches.  This is necessary
#        because of the way the script operates.
#
# Examples:
#
# Check for login failures in the syslog...
#
#   check_log /var/log/messages ./check_log.badlogins.old "LOGIN FAILURE"
#
# Check for port scan alerts generated by Psionic's PortSentry software...
#
#   check_log /var/log/message ./check_log.portscan.old "attackalert"
#

# Paths to commands used in this script.  These
# may have to be modified to match your system setup.
# TV: removed PATH restriction. Need to think more about what this means overall
#PATH=""

ECHO="/bin/echo"
PS="/bin/ps -ef"
WC="/usr/bin/wc"
GREP="/bin/grep"
DIFF="/usr/bin/diff"
TAIL="/usr/bin/tail"
CAT="/bin/cat"
RM="/bin/rm"
CHMOD="/bin/chmod"
TOUCH="/bin/touch"
FREE="/usr/bin/free"
FGREP="/bin/fgrep"

#PROGNAME=`/bin/basename $0`
#PROGPATH=`echo $0 | sed -e 's,[\\/][^\\/][^\\/]*$,,'`
#REVISION="1.4.15"

#. $PROGPATH/utils.sh


STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3
STATE_DEPENDENT=4
CRIT=$2
WARN=$1

MEM_TOTAL=`$FREE | $FGREP "Mem:" | awk '{print $2}'`;
MEM_USED=`$FREE | fgrep "/+ buffers/cache" | awk '{print $3}'`;
PERCENTAGE=$(($MEM_USED*100/$MEM_TOTAL))
 
if [ "$PERCENTAGE" -gt "$CRIT" ]; then
    $ECHO " Memory Critical! - Memory Usage is $PERCENTAGE %" 
    exitstatus=$STATE_CRITICAL
fi
#
if [ "$PERCENTAGE" \> "$WARN" ] && [ "$PERCENTAGE" \< "$CRIT" ]; then
    $ECHO " Memory Warning! - Memory Usage is $PERCENTAGE %" 
    exitstatus=$STATE_WARNING
fi
#
if [ "$PERCENTAGE" -lt "$WARN" ]; then
    $ECHO " Memory OK - Memory Usage is $PERCENTAGE %" 
    exitstatus=$STATE_OK
fi

exit $exitstatus

