[root@nets pnp4nagios]# cat /usr/lib64/nagios/plugins/check_selinux 
#! /bin/sh
#
# Description:
#
# This plugin will scan a log file (specified by the <log_file> option)
# for a specific pattern (specified by the <pattern> option).  Successive
# calls to the plugin script will only report *new* pattern matches in the
# log file, since an copy of the log file from the previous run is saved
# to <old_log_file>.
#
# Output:
#
# On the first run of the plugin, it will return an OK state with a message
# of "Log check data initialized".  On successive runs, it will return an OK
# state if *no* pattern matches have been found in the *difference* between the
# log file and the older copy of the log file.  If the plugin detects any 
# pattern matches in the log diff, it will return a CRITICAL state and print
# out a message is the following format: "(x) last_match", where "x" is the
# total number of pattern matches found in the file and "last_match" is the
# last entry in the log file which matches the pattern.
#
# Notes:
#
# If you use this plugin make sure to keep the following in mind:
#
#    1.  The "max_attempts" value for the service should be 1, as this
#        will prevent Nagios from retrying the service check (the
#        next time the check is run it will not produce the same results).
#
#    2.  The "notify_recovery" value for the service should be 0, so that
#        Nagios does not notify you of "recoveries" for the check.  Since
#        pattern matches in the log file will only be reported once and not
#        the next time, there will always be "recoveries" for the service, even
#        though recoveries really don't apply to this type of check.
#
#    3.  You *must* supply a different <old_file_log> for each service that
#        you define to use this plugin script - even if the different services
#        check the same <log_file> for pattern matches.  This is necessary
#        because of the way the script operates.
#
# Examples:
#
# Check for login failures in the syslog...
#
#   check_log /var/log/messages ./check_log.badlogins.old "LOGIN FAILURE"
#
# Check for port scan alerts generated by Psionic's PortSentry software...
#
#   check_log /var/log/message ./check_log.portscan.old "attackalert"
#

# Paths to commands used in this script.  These
# may have to be modified to match your system setup.
# TV: removed PATH restriction. Need to think more about what this means overall
#PATH=""

ECHO="/bin/echo"
PS="/bin/ps -ef"
WC="/usr/bin/wc"
GREP="/bin/grep"
DIFF="/usr/bin/diff"
TAIL="/usr/bin/tail"
CAT="/bin/cat"
RM="/bin/rm"
CHMOD="/bin/chmod"
TOUCH="/bin/touch"
SELINUX=`/usr/sbin/getenforce`

#PROGNAME=`/bin/basename $0`
#PROGPATH=`echo $0 | sed -e 's,[\\/][^\\/][^\\/]*$,,'`
#REVISION="1.4.15"

#. $PROGPATH/utils.sh


STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3
STATE_DEPENDENT=4


if [ "$SELINUX" == "Disabled" ]; then
    $ECHO "Selinux is NOT RUNNING! - Selinux is NOT ENFORCING!"
    #exitstatus=$STATE_CRITICAL
    exitstatus=$STATE_OK
fi
#
if [ "$SELINUX" == "Permissive" ]; then # no matches, exit with no error
    $ECHO "Selinux is running in PERMISSIVE mode! - Selinux is NOT ENFORCING!"
    #exitstatus=$STATE_WARNING
    exitstatus=$STATE_OK
fi
#
if [ "$SELINUX" == "Enforcing" ]; then 
    $ECHO "Selinux is running in ENFORCING mode! - Selinux IS ENFORCING!"
    exitstatus=$STATE_OK
fi

exit $exitstatus
